{"remainingRequest":"D:\\Git Projects\\Standar Portal\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Git Projects\\Standar Portal\\node_modules\\ngx-bootstrap\\modal\\modal.directive.js","dependencies":[{"path":"D:\\Git Projects\\Standar Portal\\node_modules\\ngx-bootstrap\\modal\\modal.directive.js","mtime":499162500000},{"path":"D:\\Git Projects\\Standar Portal\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1624878985141},{"path":"D:\\Git Projects\\Standar Portal\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/* tslint:disable:max-file-line-count */\n// todo: should we support enforce focus in?\n// todo: in original bs there are was a way to prevent modal from showing\n// todo: original modal had resize events\nimport { Directive, ElementRef, EventEmitter, HostListener, Input, Output, Renderer2, ViewContainerRef } from '@angular/core';\nimport { document, window } from '../utils/facade/browser';\nimport { isBs3 } from '../utils/theme-provider';\nimport { Utils } from '../utils/utils.class';\nimport { ModalBackdropComponent } from './modal-backdrop.component';\nimport { CLASS_NAME, DISMISS_REASONS, modalConfigDefaults } from './modal-options.class';\nimport { ComponentLoaderFactory } from '../component-loader/component-loader.factory';\nvar TRANSITION_DURATION = 300;\nvar BACKDROP_TRANSITION_DURATION = 150;\n/** Mark any code with directive to show it's content in modal */\nvar ModalDirective = /** @class */ /*@__PURE__*/ (function () {\n    function ModalDirective(_element, _viewContainerRef, _renderer, clf) {\n        this._element = _element;\n        this._renderer = _renderer;\n        /** This event fires immediately when the `show` instance method is called. */\n        this.onShow = new EventEmitter();\n        /** This event is fired when the modal has been made visible to the user\n           * (will wait for CSS transitions to complete)\n           */\n        this.onShown = new EventEmitter();\n        /** This event is fired immediately when\n           * the hide instance method has been called.\n           */\n        this.onHide = new EventEmitter();\n        /** This event is fired when the modal has finished being\n           * hidden from the user (will wait for CSS transitions to complete).\n           */\n        this.onHidden = new EventEmitter();\n        this._isShown = false;\n        this.isBodyOverflowing = false;\n        this.originalBodyPadding = 0;\n        this.scrollbarWidth = 0;\n        this.timerHideModal = 0;\n        this.timerRmBackDrop = 0;\n        this.isNested = false;\n        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n    }\n    Object.defineProperty(ModalDirective.prototype, \"config\", {\n        get: function () {\n            return this._config;\n        },\n        set: /** allows to set modal configuration via element property */ function (conf) {\n            this._config = this.getConfig(conf);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ModalDirective.prototype, \"isShown\", {\n        get: function () {\n            return this._isShown;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ModalDirective.prototype.onClick = function (event) {\n        if (this.config.ignoreBackdropClick ||\n            this.config.backdrop === 'static' ||\n            event.target !== this._element.nativeElement) {\n            return;\n        }\n        this.dismissReason = DISMISS_REASONS.BACKRDOP;\n        this.hide(event);\n    };\n    // todo: consider preventing default and stopping propagation\n    ModalDirective.prototype.onEsc =\n        // todo: consider preventing default and stopping propagation\n        function (event) {\n            if (!this._isShown) {\n                return;\n            }\n            if (event.keyCode === 27) {\n                event.preventDefault();\n            }\n            if (this.config.keyboard) {\n                this.dismissReason = DISMISS_REASONS.ESC;\n                this.hide();\n            }\n        };\n    ModalDirective.prototype.ngOnDestroy = function () {\n        this.config = void 0;\n        if (this._isShown) {\n            this._isShown = false;\n            this.hideModal();\n            this._backdrop.dispose();\n        }\n    };\n    ModalDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        this._config = this._config || this.getConfig();\n        setTimeout(function () {\n            if (_this._config.show) {\n                _this.show();\n            }\n        }, 0);\n    };\n    /* Public methods */\n    /** Allows to manually toggle modal visibility */\n    /* Public methods */\n    /** Allows to manually toggle modal visibility */\n    ModalDirective.prototype.toggle = /* Public methods */\n        /** Allows to manually toggle modal visibility */\n        function () {\n            return this._isShown ? this.hide() : this.show();\n        };\n    /** Allows to manually open modal */\n    /** Allows to manually open modal */\n    ModalDirective.prototype.show = /** Allows to manually open modal */\n        function () {\n            var _this = this;\n            this.dismissReason = null;\n            this.onShow.emit(this);\n            if (this._isShown) {\n                return;\n            }\n            clearTimeout(this.timerHideModal);\n            clearTimeout(this.timerRmBackDrop);\n            this._isShown = true;\n            this.checkScrollbar();\n            this.setScrollbar();\n            if (document && document.body) {\n                if (document.body.classList.contains(CLASS_NAME.OPEN)) {\n                    this.isNested = true;\n                }\n                else {\n                    this._renderer.addClass(document.body, CLASS_NAME.OPEN);\n                }\n            }\n            this.showBackdrop(function () {\n                _this.showElement();\n            });\n        };\n    /** Allows to manually close modal */\n    /** Allows to manually close modal */\n    ModalDirective.prototype.hide = /** Allows to manually close modal */\n        function (event) {\n            var _this = this;\n            if (event) {\n                event.preventDefault();\n            }\n            this.onHide.emit(this);\n            // todo: add an option to prevent hiding\n            if (!this._isShown) {\n                return;\n            }\n            clearTimeout(this.timerHideModal);\n            clearTimeout(this.timerRmBackDrop);\n            this._isShown = false;\n            this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);\n            if (!isBs3()) {\n                this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);\n            }\n            // this._addClassIn = false;\n            if (this._config.animated) {\n                this.timerHideModal = setTimeout(function () { return _this.hideModal(); }, TRANSITION_DURATION);\n            }\n            else {\n                this.hideModal();\n            }\n        };\n    /** Private methods @internal */\n    /** Private methods @internal */\n    ModalDirective.prototype.getConfig = /** Private methods @internal */\n        function (config) {\n            return Object.assign({}, modalConfigDefaults, config);\n        };\n    /**\n     *  Show dialog\n     *  @internal\n     */\n    /**\n       *  Show dialog\n       *  @internal\n       */\n    ModalDirective.prototype.showElement = /**\n       *  Show dialog\n       *  @internal\n       */\n        function () {\n            var _this = this;\n            // todo: replace this with component loader usage\n            if (!this._element.nativeElement.parentNode ||\n                this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {\n                // don't move modals dom position\n                if (document && document.body) {\n                    document.body.appendChild(this._element.nativeElement);\n                }\n            }\n            this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n            this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');\n            this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n            this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n            if (this._config.animated) {\n                Utils.reflow(this._element.nativeElement);\n            }\n            // this._addClassIn = true;\n            this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);\n            if (!isBs3()) {\n                this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);\n            }\n            var transitionComplete = function () {\n                if (_this._config.focus) {\n                    _this._element.nativeElement.focus();\n                }\n                _this.onShown.emit(_this);\n            };\n            if (this._config.animated) {\n                setTimeout(transitionComplete, TRANSITION_DURATION);\n            }\n            else {\n                transitionComplete();\n            }\n        };\n    /** @internal */\n    /** @internal */\n    ModalDirective.prototype.hideModal = /** @internal */\n        function () {\n            var _this = this;\n            this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n            this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n            this.showBackdrop(function () {\n                if (!_this.isNested) {\n                    if (document && document.body) {\n                        _this._renderer.removeClass(document.body, CLASS_NAME.OPEN);\n                    }\n                    _this.resetScrollbar();\n                }\n                _this.resetAdjustments();\n                _this.focusOtherModal();\n                _this.onHidden.emit(_this);\n            });\n        };\n    // todo: original show was calling a callback when done, but we can use\n    // promise\n    /** @internal */\n    // todo: original show was calling a callback when done, but we can use\n    // promise\n    /** @internal */\n    ModalDirective.prototype.showBackdrop =\n        // todo: original show was calling a callback when done, but we can use\n        // promise\n        /** @internal */\n        function (callback) {\n            var _this = this;\n            if (this._isShown &&\n                this.config.backdrop &&\n                (!this.backdrop || !this.backdrop.instance.isShown)) {\n                this.removeBackdrop();\n                this._backdrop\n                    .attach(ModalBackdropComponent)\n                    .to('body')\n                    .show({ isAnimated: this._config.animated });\n                this.backdrop = this._backdrop._componentRef;\n                if (!callback) {\n                    return;\n                }\n                if (!this._config.animated) {\n                    callback();\n                    return;\n                }\n                setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n            }\n            else if (!this._isShown && this.backdrop) {\n                this.backdrop.instance.isShown = false;\n                var callbackRemove = function () {\n                    _this.removeBackdrop();\n                    if (callback) {\n                        callback();\n                    }\n                };\n                if (this.backdrop.instance.isAnimated) {\n                    this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n                }\n                else {\n                    callbackRemove();\n                }\n            }\n            else if (callback) {\n                callback();\n            }\n        };\n    /** @internal */\n    /** @internal */\n    ModalDirective.prototype.removeBackdrop = /** @internal */\n        function () {\n            this._backdrop.hide();\n        };\n    /** Events tricks */\n    // no need for it\n    // protected setEscapeEvent():void {\n    //   if (this._isShown && this._config.keyboard) {\n    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n    //       if (event.which === 27) {\n    //         this.hide()\n    //       }\n    //     })\n    //\n    //   } else if (!this._isShown) {\n    //     $(this._element).off(Event.KEYDOWN_DISMISS)\n    //   }\n    // }\n    // protected setResizeEvent():void {\n    // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n    // if (this._isShown) {\n    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n    // } else {\n    //   $(window).off(Event.RESIZE)\n    // }\n    // }\n    /** Events tricks */\n    // no need for it\n    // protected setEscapeEvent():void {\n    //   if (this._isShown && this._config.keyboard) {\n    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n    //       if (event.which === 27) {\n    //         this.hide()\n    //       }\n    //     })\n    //\n    //   } else if (!this._isShown) {\n    //     $(this._element).off(Event.KEYDOWN_DISMISS)\n    //   }\n    // }\n    // protected setResizeEvent():void {\n    // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n    // if (this._isShown) {\n    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n    // } else {\n    //   $(window).off(Event.RESIZE)\n    // }\n    // }\n    ModalDirective.prototype.focusOtherModal = /** Events tricks */\n        // no need for it\n        // protected setEscapeEvent():void {\n        //   if (this._isShown && this._config.keyboard) {\n        //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n        //       if (event.which === 27) {\n        //         this.hide()\n        //       }\n        //     })\n        //\n        //   } else if (!this._isShown) {\n        //     $(this._element).off(Event.KEYDOWN_DISMISS)\n        //   }\n        // }\n        // protected setResizeEvent():void {\n        // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n        // if (this._isShown) {\n        //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n        // } else {\n        //   $(window).off(Event.RESIZE)\n        // }\n        // }\n        function () {\n            if (this._element.nativeElement.parentElement == null)\n                return;\n            var otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');\n            if (!otherOpenedModals.length) {\n                return;\n            }\n            otherOpenedModals[otherOpenedModals.length - 1].focus();\n        };\n    /** @internal */\n    /** @internal */\n    ModalDirective.prototype.resetAdjustments = /** @internal */\n        function () {\n            this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n            this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n        };\n    /** Scroll bar tricks */\n    /** @internal */\n    /** Scroll bar tricks */\n    /** @internal */\n    ModalDirective.prototype.checkScrollbar = /** Scroll bar tricks */\n        /** @internal */\n        function () {\n            this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n            this.scrollbarWidth = this.getScrollbarWidth();\n        };\n    ModalDirective.prototype.setScrollbar = function () {\n        if (!document) {\n            return;\n        }\n        this.originalBodyPadding = parseInt(window\n            .getComputedStyle(document.body)\n            .getPropertyValue('padding-right') || 0, 10);\n        if (this.isBodyOverflowing) {\n            document.body.style.paddingRight = this.originalBodyPadding +\n                this.scrollbarWidth + \"px\";\n        }\n    };\n    ModalDirective.prototype.resetScrollbar = function () {\n        document.body.style.paddingRight = this.originalBodyPadding + 'px';\n    };\n    // thx d.walsh\n    // thx d.walsh\n    ModalDirective.prototype.getScrollbarWidth =\n        // thx d.walsh\n        function () {\n            var scrollDiv = this._renderer.createElement('div');\n            this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);\n            this._renderer.appendChild(document.body, scrollDiv);\n            var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n            this._renderer.removeChild(document.body, scrollDiv);\n            return scrollbarWidth;\n        };\n    return ModalDirective;\n}());\nexport { ModalDirective };\n//# sourceMappingURL=modal.directive.js.map\n",null]}